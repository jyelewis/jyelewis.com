---
title: "(Ab)using AWS DynamoDB for full text search"
description: "They say 'infinite scale', we say 'how infinite'"
timeToRead: 5
---

About a year ago, I had the ridiculous idea to build a text indexer on top of [AWS DynamoDB](https://aws.amazon.com/dynamodb/).

I love DynamoDB, and will use it whenever possible.
 * It's fully managed, no maintenance or updates required.
 * You only pay for what you use, no fee to have a table exist if it's not being used.
 * It forces you to select an appropriate schema for fast data access.
 * They aren't lying about it's scaling ability, this thing can grow horizontally for miles.

// TODO: split this out into its own article

## Full text search
### What is full text search?
Full text search (FTS for short) is a method of storing & querying blocks of text
such that a user can search for any word of phrase and efficiently have all documents matching that phrase returned.

Search engines such as Google are one of the largest examples of FTS. Effectively indexing all the visible content on the internet and performing searches across that dataset in under a second.

### How full text search works
> *Disclaimer: text search is a large and complicated topic, this has been intentionally reduced to a very simple version*

Consider the phrase `"That fox is quick & brown!"`

There are many matching words & phrases in here:
 * `"That fox"`
 * `"Fox"`
 * `"Quick & brown"`
 * `"Fox is quick"`
 * `"Brown"`
 * etc.

Complicating further, someone searching may not use the exact same grammar in their search term, but expect a match.

i.e. `"Fox: quick, brown"` should probably match `"That fox is quick & brown!"`

#### Tokenisation
To achieve this, full text breaks text into many *tokens*.
Tokenisation is a multi-step process.

// TODO: text transform gif?

 1. Convert to lowercase
     * `That fox is quick & brown!` -> `that fox is quick & brown!`
 2. Flatten symbols & boundary characters into a standard character & reduce to 1 sequential delimiter
     * `that fox is quick & brown!` -> `that fox is quick brown`
     * `hello, tommy-lee!` -> `hello tommy lee`
 3. Remove [stop words](https://en.wikipedia.org/wiki/Stop_word) (words insignificant to searching, i.e 'the', 'is', 'a', 'their')
     * `that fox is quick brown` -> `fox quick brown`
 4. Break into tokens on boundaries (delimiters such as hyphen, space, parentheses)
     * `fox quick brown`
     * `quick brown`
     * `brown`

These tokens are then all stored in a format that allows efficiently searching for records based on the characters a token starts with.

The easiest example of one of these formats is a dictionary, by storing all words alphabetically it's easy to find all words starting with `"tra"` by navigating back and forth through the book.

#### Searching tokens
When a search term is entered, it goes through a similar clean up process as tokenisation.
 1. Convert to lowercase
 2. Flatten symbols & boundary characters
 3. Remove stop words

`Fox: quick, brown` -> `fox quick brown`

We can then use our dictionary trick to find any tokens we've stored starting with, or matching `fox quick brown`.
Once we find a matching token, we look across to see what record it references and find out original document: `That fox is quick & brown!`

## How DynamoDB stores documents

## Using DynamoDB indexes to quickly find segments

## Making it happen

## In reality

### Performance & scalability

### Cost

### Limitations


## Summary
